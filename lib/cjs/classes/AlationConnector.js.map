{"version":3,"sources":["../../../src/classes/AlationConnector.ts"],"names":["AlationConnector","constructor","user","alationURL","options","defaultOptions","jobInterval","tokenName","accessTokenPath","path","resolve","process","cwd","refreshTokenPath","charAt","length","slice","apiClient","axios","create","baseURL","interceptors","request","use","config","headers","Token","getAccessToken","api_access_token","response","error","status","HTTP_STATUS","FORBIDDEN","regenerateAccessToken","fs","existsSync","JSON","parse","readFileSync","encoding","console","message","getRefreshToken","createOrUpdateRefreshToken","refreshToken","validateToken","data","post","refresh_token","user_id","saveToken","oldToken","name","token","token_status","TokenStatusEnum","ACTIVE","accessToken","unlinkSync","writeFileSync","stringify"],"mappings":"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","sourcesContent":["import fs from 'fs';\nimport {\n  createAccessTokenRoute,\n  createRefreshTokenRoute,\n  HTTP_STATUS,\n  regenerateRefreshTokenRoute,\n  validateAccessTokenRoute,\n  validateRefreshTokenRoute,\n} from '../constants';\nimport axios, {AxiosError, AxiosInstance, AxiosRequestConfig} from 'axios';\nimport {IAccessToken, IConnectorAuthConfig, IRefreshToken} from '../interfaces';\nimport {TokenStatusEnum} from '../types';\nimport path from 'path';\n\nexport type IConnectorOptions = Partial<IConnectorConfig>;\n\nexport abstract class AlationConnector {\n  protected apiClient: AxiosInstance;\n  protected options: IConnectorConfig;\n\n  private readonly user: IConnectorAuthConfig;\n  private readonly alationURL: string;\n  private readonly accessTokenPath:string;\n  private readonly refreshTokenPath:string;\n\n  protected constructor(user: IConnectorAuthConfig, alationURL: string, options?: IConnectorOptions) {\n    this.user = user;\n    const defaultOptions: IConnectorConfig = {\n      jobInterval: 1000,\n      tokenName: 'connector_token',\n    };\n    this.options = {...defaultOptions, ...options};\n\n    this.accessTokenPath = path.resolve(process.cwd(), `keys/alation_connector_${this.options.tokenName}_access_token.json`);\n    this.refreshTokenPath = path.resolve(process.cwd(), `keys/alation_connector_${this.options.tokenName}_refresh_token.json`);\n\n    this.alationURL = alationURL.charAt(alationURL.length - 1) === '/' ? alationURL.slice(0, alationURL.length - 1) : alationURL;\n    this.apiClient = axios.create({baseURL: this.alationURL});\n    // Привязка токена\n    this.apiClient.interceptors.request.use(async (config: AxiosRequestConfig) => {\n      config.headers.Token = (await this.getAccessToken()).api_access_token;\n      return config;\n    });\n    // Обработка ошибки сгорания токена\n    this.apiClient.interceptors.response.use((response) => response, async (error: AxiosError) => {\n      if (!error.response || error.response.status !== HTTP_STATUS.FORBIDDEN) {\n        return error;\n      }\n      const {config} = error.response;\n      config.headers.Token = (await this.regenerateAccessToken()).api_access_token;\n      return axios(config);\n    });\n  }\n\n  private async getAccessToken(): Promise<IAccessToken> {\n    try {\n      if (fs.existsSync(this.accessTokenPath)) {\n        return JSON.parse(fs.readFileSync(this.accessTokenPath, {encoding: 'utf-8'}));\n      }\n      return this.regenerateAccessToken();\n    } catch (error) {\n      console.error('CODE00000200 cant load or write alation access token key');\n      console.error(error.message);\n      throw error;\n    }\n  }\n\n  private async getRefreshToken(): Promise<IRefreshToken> {\n    try {\n      if (fs.existsSync(this.refreshTokenPath)) {\n        return JSON.parse(fs.readFileSync(this.refreshTokenPath, {encoding: 'utf-8'}));\n      } else {\n        return this.createOrUpdateRefreshToken();\n      }\n    } catch (error) {\n      console.error('CODE00000201 cant load or write alation refresh token key');\n      console.error(error.message);\n      throw error;\n    }\n  }\n\n  private async regenerateAccessToken(): Promise<IAccessToken> {\n    let refreshToken = await this.getRefreshToken();\n    if (!(await this.validateToken(refreshToken))) {\n      refreshToken = await this.createOrUpdateRefreshToken(refreshToken);\n    }\n    const {data} = await axios.post<IAccessToken>(createAccessTokenRoute(this.alationURL), {\n      refresh_token: refreshToken.refresh_token,\n      user_id: refreshToken.user_id,\n    });\n    this.saveToken(data);\n    return data;\n  }\n\n  private async createOrUpdateRefreshToken(oldToken?: IRefreshToken): Promise<IRefreshToken> {\n    try {\n      if (oldToken) {\n        const {data} = await axios.post<IRefreshToken>(regenerateRefreshTokenRoute(this.alationURL), {\n          refresh_token: oldToken.refresh_token,\n          user_id: oldToken.user_id,\n        });\n        this.saveToken(data);\n        return data;\n      }\n      const {data} = await axios.post<IRefreshToken>(createRefreshTokenRoute(this.alationURL), {\n        ...this.user,\n        name: this.options.tokenName,\n      });\n      this.saveToken(data);\n      return data;\n    } catch (error) {\n      console.error(`CODE00000202 createRefreshToken() finish with error: ${error?.message}`);\n      throw error;\n    }\n  }\n\n  private async validateToken(token: IAccessToken | IRefreshToken): Promise<boolean> {\n    try {\n      if ((token as IRefreshToken)['refresh_token']) {\n        const refreshToken = token as IRefreshToken;\n        const {data} = await axios.post<IRefreshToken>(validateRefreshTokenRoute(this.alationURL),\n            {\n              refresh_token: refreshToken.refresh_token,\n              user_id: refreshToken.user_id,\n            });\n        return data.token_status === TokenStatusEnum.ACTIVE;\n      }\n      const accessToken = token as IAccessToken;\n      const {data} = await axios.post<IAccessToken>(validateAccessTokenRoute(this.alationURL),\n          {\n            api_access_token: accessToken.api_access_token,\n            user_id: accessToken.user_id,\n          });\n      return data.token_status === TokenStatusEnum.ACTIVE;\n    } catch (error) {\n      if (error.response) {\n        return false;\n      }\n      console.error('CODE00000203 cant valid token, maybe token was expired or deleted');\n      console.error(error.message);\n      throw error;\n    }\n  }\n\n  private saveToken(token: IAccessToken | IRefreshToken): void {\n    const path = ((token as IRefreshToken)['refresh_token']) ? this.refreshTokenPath : this.accessTokenPath;\n    if (fs.existsSync(path)) fs.unlinkSync(path);\n    fs.writeFileSync(path, JSON.stringify(token), {encoding: 'utf-8'});\n  }\n}\n\ninterface IConnectorConfig {\n  jobInterval: number;\n  tokenName: string;\n}\n"],"file":"AlationConnector.js"}
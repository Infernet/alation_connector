{"version":3,"sources":["../../../src/classes/AlationConnector.ts"],"names":["fs","createAccessTokenRoute","createRefreshTokenRoute","HTTP_STATUS","regenerateRefreshTokenRoute","validateAccessTokenRoute","validateRefreshTokenRoute","axios","TokenStatusEnum","path","AlationConnector","constructor","user","alationURL","options","defaultOptions","jobInterval","tokenName","accessTokenPath","resolve","process","cwd","refreshTokenPath","charAt","length","slice","apiClient","create","baseURL","interceptors","request","use","config","headers","Token","getAccessToken","api_access_token","response","error","status","FORBIDDEN","regenerateAccessToken","existsSync","JSON","parse","readFileSync","encoding","console","message","getRefreshToken","createOrUpdateRefreshToken","refreshToken","validateToken","data","post","refresh_token","user_id","saveToken","oldToken","name","token","token_status","ACTIVE","accessToken","unlinkSync","writeFileSync","stringify"],"mappings":"AAAA,OAAOA,EAAP,MAAe,IAAf;AACA,SACEC,sBADF,EAEEC,uBAFF,EAGEC,WAHF,EAIEC,2BAJF,EAKEC,wBALF,EAMEC,yBANF;AAQA,OAAOC,KAAP,MAAmE,OAAnE;AAEA,SAAQC,eAAR;AACA,OAAOC,IAAP,MAAiB,MAAjB;AAIA,OAAO,MAAeC,gBAAf,CAAgC;AAS3BC,EAAAA,WAAW,CAACC,IAAD,EAA6BC,UAA7B,EAAiDC,OAAjD,EAA8E;AACjG,SAAKF,IAAL,GAAYA,IAAZ;AACA,UAAMG,cAAgC,GAAG;AACvCC,MAAAA,WAAW,EAAE,IAD0B;AAEvCC,MAAAA,SAAS,EAAE;AAF4B,KAAzC;AAIA,SAAKH,OAAL,GAAe,EAAC,GAAGC,cAAJ;AAAoB,SAAGD;AAAvB,KAAf;AAEA,SAAKI,eAAL,GAAuBT,IAAI,CAACU,OAAL,CAAaC,OAAO,CAACC,GAAR,EAAb,EAA6B,0BAAyB,KAAKP,OAAL,CAAaG,SAAU,oBAA7E,CAAvB;AACA,SAAKK,gBAAL,GAAwBb,IAAI,CAACU,OAAL,CAAaC,OAAO,CAACC,GAAR,EAAb,EAA6B,0BAAyB,KAAKP,OAAL,CAAaG,SAAU,qBAA7E,CAAxB;AAEA,SAAKJ,UAAL,GAAkBA,UAAU,CAACU,MAAX,CAAkBV,UAAU,CAACW,MAAX,GAAoB,CAAtC,MAA6C,GAA7C,GAAmDX,UAAU,CAACY,KAAX,CAAiB,CAAjB,EAAoBZ,UAAU,CAACW,MAAX,GAAoB,CAAxC,CAAnD,GAAgGX,UAAlH;AACA,SAAKa,SAAL,GAAiBnB,KAAK,CAACoB,MAAN,CAAa;AAACC,MAAAA,OAAO,EAAE,KAAKf;AAAf,KAAb,CAAjB,CAZiG,CAajG;;AACA,SAAKa,SAAL,CAAeG,YAAf,CAA4BC,OAA5B,CAAoCC,GAApC,CAAwC,MAAOC,MAAP,IAAsC;AAC5EA,MAAAA,MAAM,CAACC,OAAP,CAAeC,KAAf,GAAuB,CAAC,MAAM,KAAKC,cAAL,EAAP,EAA8BC,gBAArD;AACA,aAAOJ,MAAP;AACD,KAHD,EAdiG,CAkBjG;;AACA,SAAKN,SAAL,CAAeG,YAAf,CAA4BQ,QAA5B,CAAqCN,GAArC,CAA0CM,QAAD,IAAcA,QAAvD,EAAiE,MAAOC,KAAP,IAA6B;AAC5F,UAAI,CAACA,KAAK,CAACD,QAAP,IAAmBC,KAAK,CAACD,QAAN,CAAeE,MAAf,KAA0BpC,WAAW,CAACqC,SAA7D,EAAwE;AACtE,eAAOF,KAAP;AACD;;AACD,YAAM;AAACN,QAAAA;AAAD,UAAWM,KAAK,CAACD,QAAvB;AACAL,MAAAA,MAAM,CAACC,OAAP,CAAeC,KAAf,GAAuB,CAAC,MAAM,KAAKO,qBAAL,EAAP,EAAqCL,gBAA5D;AACA,aAAO7B,KAAK,CAACyB,MAAD,CAAZ;AACD,KAPD;AAQD;;AAE2B,QAAdG,cAAc,GAA0B;AACpD,QAAI;AACF,UAAInC,EAAE,CAAC0C,UAAH,CAAc,KAAKxB,eAAnB,CAAJ,EAAyC;AACvC,eAAOyB,IAAI,CAACC,KAAL,CAAW5C,EAAE,CAAC6C,YAAH,CAAgB,KAAK3B,eAArB,EAAsC;AAAC4B,UAAAA,QAAQ,EAAE;AAAX,SAAtC,CAAX,CAAP;AACD;;AACD,aAAO,KAAKL,qBAAL,EAAP;AACD,KALD,CAKE,OAAOH,KAAP,EAAc;AACdS,MAAAA,OAAO,CAACT,KAAR,CAAc,0DAAd;AACAS,MAAAA,OAAO,CAACT,KAAR,CAAcA,KAAK,CAACU,OAApB;AACA,YAAMV,KAAN;AACD;AACF;;AAE4B,QAAfW,eAAe,GAA2B;AACtD,QAAI;AACF,UAAIjD,EAAE,CAAC0C,UAAH,CAAc,KAAKpB,gBAAnB,CAAJ,EAA0C;AACxC,eAAOqB,IAAI,CAACC,KAAL,CAAW5C,EAAE,CAAC6C,YAAH,CAAgB,KAAKvB,gBAArB,EAAuC;AAACwB,UAAAA,QAAQ,EAAE;AAAX,SAAvC,CAAX,CAAP;AACD,OAFD,MAEO;AACL,eAAO,KAAKI,0BAAL,EAAP;AACD;AACF,KAND,CAME,OAAOZ,KAAP,EAAc;AACdS,MAAAA,OAAO,CAACT,KAAR,CAAc,2DAAd;AACAS,MAAAA,OAAO,CAACT,KAAR,CAAcA,KAAK,CAACU,OAApB;AACA,YAAMV,KAAN;AACD;AACF;;AAEkC,QAArBG,qBAAqB,GAA0B;AAC3D,QAAIU,YAAY,GAAG,MAAM,KAAKF,eAAL,EAAzB;;AACA,QAAI,EAAE,MAAM,KAAKG,aAAL,CAAmBD,YAAnB,CAAR,CAAJ,EAA+C;AAC7CA,MAAAA,YAAY,GAAG,MAAM,KAAKD,0BAAL,CAAgCC,YAAhC,CAArB;AACD;;AACD,UAAM;AAACE,MAAAA;AAAD,QAAS,MAAM9C,KAAK,CAAC+C,IAAN,CAAyBrD,sBAAsB,CAAC,KAAKY,UAAN,CAA/C,EAAkE;AACrF0C,MAAAA,aAAa,EAAEJ,YAAY,CAACI,aADyD;AAErFC,MAAAA,OAAO,EAAEL,YAAY,CAACK;AAF+D,KAAlE,CAArB;AAIA,SAAKC,SAAL,CAAeJ,IAAf;AACA,WAAOA,IAAP;AACD;;AAEuC,QAA1BH,0BAA0B,CAACQ,QAAD,EAAmD;AACzF,QAAI;AACF,UAAIA,QAAJ,EAAc;AACZ,cAAM;AAACL,UAAAA;AAAD,YAAS,MAAM9C,KAAK,CAAC+C,IAAN,CAA0BlD,2BAA2B,CAAC,KAAKS,UAAN,CAArD,EAAwE;AAC3F0C,UAAAA,aAAa,EAAEG,QAAQ,CAACH,aADmE;AAE3FC,UAAAA,OAAO,EAAEE,QAAQ,CAACF;AAFyE,SAAxE,CAArB;AAIA,aAAKC,SAAL,CAAeJ,IAAf;AACA,eAAOA,IAAP;AACD;;AACD,YAAM;AAACA,QAAAA;AAAD,UAAS,MAAM9C,KAAK,CAAC+C,IAAN,CAA0BpD,uBAAuB,CAAC,KAAKW,UAAN,CAAjD,EAAoE,EACvF,GAAG,KAAKD,IAD+E;AAEvF+C,QAAAA,IAAI,EAAE,KAAK7C,OAAL,CAAaG;AAFoE,OAApE,CAArB;AAIA,WAAKwC,SAAL,CAAeJ,IAAf;AACA,aAAOA,IAAP;AACD,KAfD,CAeE,OAAOf,KAAP,EAAc;AACdS,MAAAA,OAAO,CAACT,KAAR,CAAe,wDAAuDA,KAAxD,aAAwDA,KAAxD,uBAAwDA,KAAK,CAAEU,OAAQ,EAArF;AACA,YAAMV,KAAN;AACD;AACF;;AAE0B,QAAbc,aAAa,CAACQ,KAAD,EAAwD;AACjF,QAAI;AACF,UAAKA,KAAD,CAAyB,eAAzB,CAAJ,EAA+C;AAC7C,cAAMT,YAAY,GAAGS,KAArB;AACA,cAAM;AAACP,UAAAA;AAAD,YAAS,MAAM9C,KAAK,CAAC+C,IAAN,CAA0BhD,yBAAyB,CAAC,KAAKO,UAAN,CAAnD,EACjB;AACE0C,UAAAA,aAAa,EAAEJ,YAAY,CAACI,aAD9B;AAEEC,UAAAA,OAAO,EAAEL,YAAY,CAACK;AAFxB,SADiB,CAArB;AAKA,eAAOH,IAAI,CAACQ,YAAL,KAAsBrD,eAAe,CAACsD,MAA7C;AACD;;AACD,YAAMC,WAAW,GAAGH,KAApB;AACA,YAAM;AAACP,QAAAA;AAAD,UAAS,MAAM9C,KAAK,CAAC+C,IAAN,CAAyBjD,wBAAwB,CAAC,KAAKQ,UAAN,CAAjD,EACjB;AACEuB,QAAAA,gBAAgB,EAAE2B,WAAW,CAAC3B,gBADhC;AAEEoB,QAAAA,OAAO,EAAEO,WAAW,CAACP;AAFvB,OADiB,CAArB;AAKA,aAAOH,IAAI,CAACQ,YAAL,KAAsBrD,eAAe,CAACsD,MAA7C;AACD,KAjBD,CAiBE,OAAOxB,KAAP,EAAc;AACd,UAAIA,KAAK,CAACD,QAAV,EAAoB;AAClB,eAAO,KAAP;AACD;;AACDU,MAAAA,OAAO,CAACT,KAAR,CAAc,mEAAd;AACAS,MAAAA,OAAO,CAACT,KAAR,CAAcA,KAAK,CAACU,OAApB;AACA,YAAMV,KAAN;AACD;AACF;;AAEOmB,EAAAA,SAAS,CAACG,KAAD,EAA4C;AAC3D,UAAMnD,IAAI,GAAKmD,KAAD,CAAyB,eAAzB,CAAD,GAA8C,KAAKtC,gBAAnD,GAAsE,KAAKJ,eAAxF;AACA,QAAIlB,EAAE,CAAC0C,UAAH,CAAcjC,IAAd,CAAJ,EAAyBT,EAAE,CAACgE,UAAH,CAAcvD,IAAd;AACzBT,IAAAA,EAAE,CAACiE,aAAH,CAAiBxD,IAAjB,EAAuBkC,IAAI,CAACuB,SAAL,CAAeN,KAAf,CAAvB,EAA8C;AAACd,MAAAA,QAAQ,EAAE;AAAX,KAA9C;AACD;;AApIoC","sourcesContent":["import fs from 'fs';\nimport {\n  createAccessTokenRoute,\n  createRefreshTokenRoute,\n  HTTP_STATUS,\n  regenerateRefreshTokenRoute,\n  validateAccessTokenRoute,\n  validateRefreshTokenRoute,\n} from '../constants';\nimport axios, {AxiosError, AxiosInstance, AxiosRequestConfig} from 'axios';\nimport {IAccessToken, IConnectorAuthConfig, IRefreshToken} from '../interfaces';\nimport {TokenStatusEnum} from '../types';\nimport path from 'path';\n\nexport type IConnectorOptions = Partial<IConnectorConfig>;\n\nexport abstract class AlationConnector {\n  protected apiClient: AxiosInstance;\n  protected options: IConnectorConfig;\n\n  private readonly user: IConnectorAuthConfig;\n  private readonly alationURL: string;\n  private readonly accessTokenPath:string;\n  private readonly refreshTokenPath:string;\n\n  protected constructor(user: IConnectorAuthConfig, alationURL: string, options?: IConnectorOptions) {\n    this.user = user;\n    const defaultOptions: IConnectorConfig = {\n      jobInterval: 1000,\n      tokenName: 'connector_token',\n    };\n    this.options = {...defaultOptions, ...options};\n\n    this.accessTokenPath = path.resolve(process.cwd(), `keys/alation_connector_${this.options.tokenName}_access_token.json`);\n    this.refreshTokenPath = path.resolve(process.cwd(), `keys/alation_connector_${this.options.tokenName}_refresh_token.json`);\n\n    this.alationURL = alationURL.charAt(alationURL.length - 1) === '/' ? alationURL.slice(0, alationURL.length - 1) : alationURL;\n    this.apiClient = axios.create({baseURL: this.alationURL});\n    // Привязка токена\n    this.apiClient.interceptors.request.use(async (config: AxiosRequestConfig) => {\n      config.headers.Token = (await this.getAccessToken()).api_access_token;\n      return config;\n    });\n    // Обработка ошибки сгорания токена\n    this.apiClient.interceptors.response.use((response) => response, async (error: AxiosError) => {\n      if (!error.response || error.response.status !== HTTP_STATUS.FORBIDDEN) {\n        return error;\n      }\n      const {config} = error.response;\n      config.headers.Token = (await this.regenerateAccessToken()).api_access_token;\n      return axios(config);\n    });\n  }\n\n  private async getAccessToken(): Promise<IAccessToken> {\n    try {\n      if (fs.existsSync(this.accessTokenPath)) {\n        return JSON.parse(fs.readFileSync(this.accessTokenPath, {encoding: 'utf-8'}));\n      }\n      return this.regenerateAccessToken();\n    } catch (error) {\n      console.error('CODE00000200 cant load or write alation access token key');\n      console.error(error.message);\n      throw error;\n    }\n  }\n\n  private async getRefreshToken(): Promise<IRefreshToken> {\n    try {\n      if (fs.existsSync(this.refreshTokenPath)) {\n        return JSON.parse(fs.readFileSync(this.refreshTokenPath, {encoding: 'utf-8'}));\n      } else {\n        return this.createOrUpdateRefreshToken();\n      }\n    } catch (error) {\n      console.error('CODE00000201 cant load or write alation refresh token key');\n      console.error(error.message);\n      throw error;\n    }\n  }\n\n  private async regenerateAccessToken(): Promise<IAccessToken> {\n    let refreshToken = await this.getRefreshToken();\n    if (!(await this.validateToken(refreshToken))) {\n      refreshToken = await this.createOrUpdateRefreshToken(refreshToken);\n    }\n    const {data} = await axios.post<IAccessToken>(createAccessTokenRoute(this.alationURL), {\n      refresh_token: refreshToken.refresh_token,\n      user_id: refreshToken.user_id,\n    });\n    this.saveToken(data);\n    return data;\n  }\n\n  private async createOrUpdateRefreshToken(oldToken?: IRefreshToken): Promise<IRefreshToken> {\n    try {\n      if (oldToken) {\n        const {data} = await axios.post<IRefreshToken>(regenerateRefreshTokenRoute(this.alationURL), {\n          refresh_token: oldToken.refresh_token,\n          user_id: oldToken.user_id,\n        });\n        this.saveToken(data);\n        return data;\n      }\n      const {data} = await axios.post<IRefreshToken>(createRefreshTokenRoute(this.alationURL), {\n        ...this.user,\n        name: this.options.tokenName,\n      });\n      this.saveToken(data);\n      return data;\n    } catch (error) {\n      console.error(`CODE00000202 createRefreshToken() finish with error: ${error?.message}`);\n      throw error;\n    }\n  }\n\n  private async validateToken(token: IAccessToken | IRefreshToken): Promise<boolean> {\n    try {\n      if ((token as IRefreshToken)['refresh_token']) {\n        const refreshToken = token as IRefreshToken;\n        const {data} = await axios.post<IRefreshToken>(validateRefreshTokenRoute(this.alationURL),\n            {\n              refresh_token: refreshToken.refresh_token,\n              user_id: refreshToken.user_id,\n            });\n        return data.token_status === TokenStatusEnum.ACTIVE;\n      }\n      const accessToken = token as IAccessToken;\n      const {data} = await axios.post<IAccessToken>(validateAccessTokenRoute(this.alationURL),\n          {\n            api_access_token: accessToken.api_access_token,\n            user_id: accessToken.user_id,\n          });\n      return data.token_status === TokenStatusEnum.ACTIVE;\n    } catch (error) {\n      if (error.response) {\n        return false;\n      }\n      console.error('CODE00000203 cant valid token, maybe token was expired or deleted');\n      console.error(error.message);\n      throw error;\n    }\n  }\n\n  private saveToken(token: IAccessToken | IRefreshToken): void {\n    const path = ((token as IRefreshToken)['refresh_token']) ? this.refreshTokenPath : this.accessTokenPath;\n    if (fs.existsSync(path)) fs.unlinkSync(path);\n    fs.writeFileSync(path, JSON.stringify(token), {encoding: 'utf-8'});\n  }\n}\n\ninterface IConnectorConfig {\n  jobInterval: number;\n  tokenName: string;\n}\n"],"file":"AlationConnector.js"}
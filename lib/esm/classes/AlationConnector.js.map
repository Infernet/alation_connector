{"version":3,"sources":["../../../src/classes/AlationConnector.ts"],"names":["existsSync","outputFileSync","readFileSync","unlinkSync","createAccessTokenRoute","createRefreshTokenRoute","HTTP_STATUS","regenerateRefreshTokenRoute","validateAccessTokenRoute","validateRefreshTokenRoute","axios","TokenStatusEnum","path","AlationConnector","constructor","user","alationURL","options","defaultOptions","tokenStoragePath","resolve","process","cwd","jobInterval","tokenName","accessTokenPath","refreshTokenPath","charAt","length","slice","apiClient","create","baseURL","interceptors","request","use","config","headers","Token","getAccessToken","api_access_token","response","error","status","FORBIDDEN","regenerateAccessToken","JSON","parse","encoding","console","message","getRefreshToken","createOrUpdateRefreshToken","refreshToken","validateToken","data","post","refresh_token","user_id","saveToken","oldToken","name","token","token_status","ACTIVE","accessToken","stringify"],"mappings":"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","sourcesContent":["import {existsSync, outputFileSync, readFileSync, unlinkSync} from 'fs-extra';\nimport {\n  createAccessTokenRoute,\n  createRefreshTokenRoute,\n  HTTP_STATUS,\n  regenerateRefreshTokenRoute,\n  validateAccessTokenRoute,\n  validateRefreshTokenRoute,\n} from '../constants';\nimport axios, {AxiosError, AxiosInstance, AxiosRequestConfig} from 'axios';\nimport {IAccessToken, IConnector, IConnectorAuthConfig, IConnectorConfig, IRefreshToken} from '../interfaces';\nimport {TokenStatusEnum} from '../types';\nimport path from 'path';\n\nexport type IConnectorOptions = Partial<IConnectorConfig>;\n\nexport abstract class AlationConnector implements IConnector {\n  apiClient: AxiosInstance;\n  options: IConnectorConfig;\n\n  private readonly user: IConnectorAuthConfig;\n  private readonly alationURL: string;\n  private readonly accessTokenPath: string;\n  private readonly refreshTokenPath: string;\n\n  protected constructor(user: IConnectorAuthConfig, alationURL: string, options?: IConnectorOptions) {\n    this.user = user;\n    const defaultOptions: IConnectorConfig = {\n      tokenStoragePath: path.resolve(process.cwd(), 'keys/alation/'),\n      jobInterval: 1000,\n      tokenName: 'connector_token',\n    };\n    this.options = {...defaultOptions, ...options};\n\n    this.accessTokenPath = path.resolve(this.options.tokenStoragePath, `${this.options.tokenName}_access.token.json`);\n    this.refreshTokenPath = path.resolve(this.options.tokenStoragePath, `${this.options.tokenName}_refresh.token.json`);\n\n    this.alationURL = alationURL.charAt(alationURL.length - 1) === '/' ? alationURL.slice(0, alationURL.length - 1) : alationURL;\n    this.apiClient = axios.create({baseURL: this.alationURL});\n    // Привязка токена\n    this.apiClient.interceptors.request.use(async (config: AxiosRequestConfig) => {\n      config.headers.Token = (await this.getAccessToken()).api_access_token;\n      return config;\n    });\n    // Обработка ошибки сгорания токена\n    this.apiClient.interceptors.response.use((response) => response, async (error: AxiosError) => {\n      if (!error.response || error.response.status !== HTTP_STATUS.FORBIDDEN) {\n        return error;\n      }\n      const {config} = error.response;\n      config.headers.Token = (await this.regenerateAccessToken()).api_access_token;\n      return axios(config);\n    });\n  }\n\n  private async getAccessToken(): Promise<IAccessToken> {\n    try {\n      if (existsSync(this.accessTokenPath)) {\n        return JSON.parse(readFileSync(this.accessTokenPath, {encoding: 'utf-8'}));\n      }\n      return this.regenerateAccessToken();\n    } catch (error) {\n      console.error('CODE00000200 cant load or write alation access token key');\n      console.error(error.message);\n      throw error;\n    }\n  }\n\n  private async getRefreshToken(): Promise<IRefreshToken> {\n    try {\n      if (existsSync(this.refreshTokenPath)) {\n        return JSON.parse(readFileSync(this.refreshTokenPath, {encoding: 'utf-8'}));\n      } else {\n        return this.createOrUpdateRefreshToken();\n      }\n    } catch (error) {\n      console.error('CODE00000201 cant load or write alation refresh token key');\n      console.error(error.message);\n      throw error;\n    }\n  }\n\n  private async regenerateAccessToken(): Promise<IAccessToken> {\n    let refreshToken = await this.getRefreshToken();\n    if (!(await this.validateToken(refreshToken))) {\n      refreshToken = await this.createOrUpdateRefreshToken(refreshToken);\n    }\n    const {data} = await axios.post<IAccessToken>(createAccessTokenRoute(this.alationURL), {\n      refresh_token: refreshToken.refresh_token,\n      user_id: refreshToken.user_id,\n    });\n    this.saveToken(data);\n    return data;\n  }\n\n  private async createOrUpdateRefreshToken(oldToken?: IRefreshToken): Promise<IRefreshToken> {\n    try {\n      if (oldToken) {\n        const {data} = await axios.post<IRefreshToken>(regenerateRefreshTokenRoute(this.alationURL), {\n          refresh_token: oldToken.refresh_token,\n          user_id: oldToken.user_id,\n        });\n        this.saveToken(data);\n        return data;\n      }\n      const {data} = await axios.post<IRefreshToken>(createRefreshTokenRoute(this.alationURL), {\n        ...this.user,\n        name: this.options.tokenName,\n      });\n      this.saveToken(data);\n      return data;\n    } catch (error) {\n      console.error(`CODE00000202 createRefreshToken() finish with error: ${error?.message}`);\n      throw error;\n    }\n  }\n\n  private async validateToken(token: IAccessToken | IRefreshToken): Promise<boolean> {\n    try {\n      if ((token as IRefreshToken)['refresh_token']) {\n        const refreshToken = token as IRefreshToken;\n        const {data} = await axios.post<IRefreshToken>(validateRefreshTokenRoute(this.alationURL),\n            {\n              refresh_token: refreshToken.refresh_token,\n              user_id: refreshToken.user_id,\n            });\n        return data.token_status === TokenStatusEnum.ACTIVE;\n      }\n      const accessToken = token as IAccessToken;\n      const {data} = await axios.post<IAccessToken>(validateAccessTokenRoute(this.alationURL),\n          {\n            api_access_token: accessToken.api_access_token,\n            user_id: accessToken.user_id,\n          });\n      return data.token_status === TokenStatusEnum.ACTIVE;\n    } catch (error) {\n      if (error.response) {\n        return false;\n      }\n      console.error('CODE00000203 cant valid token, maybe token was expired or deleted');\n      console.error(error.message);\n      throw error;\n    }\n  }\n\n  private saveToken(token: IAccessToken | IRefreshToken): void {\n    const path = ((token as IRefreshToken)['refresh_token']) ? this.refreshTokenPath : this.accessTokenPath;\n    if (existsSync(path)) unlinkSync(path);\n    outputFileSync(path, JSON.stringify(token), {encoding: 'utf-8'});\n  }\n}\n"],"file":"AlationConnector.js"}